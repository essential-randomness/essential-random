const id = "get-static-paths/index.mdx";
						const collection = "posts";
						const slug = "get-static-paths";
						const body = "\n## What `getStaticPaths` does in Astro (and theoretically NextJS)\n\nStatic Site Generators (SSGs) don't create pages on demand when a visitor\nrequests them. Instead, they generate them all ahead of time (the so-called\n_\"build time\"_) before your site is uploaded to the web. This creates a problem\nwhen page definitions have parameters within their URLs: **if a URL is of the\nform `/posts/[postSlug]`, what are all the possible valid values that\n`[postSlug]` can have?** Without knowing this, your SSG cannot know what pages\nit's being asked to generate. This is the question that `getStaticPaths` exists\nto answer.\n\n## `getStaticPaths` and URL parameters\n\nWhen an SSG goes to generate a page that has a dynamic parameter, it first\nsearches the code within in search of an _exported_ function (the only ones it\ncan see) named `getStaticPaths`. When called, this function will give the SSG\nthe list of all the pages it needs to work its magic on. The form this list\ntakes is **an array made up of one JavaScript object per page with the values of\nthe URL parameter(s) for that page.**\n\nLet's leverage TypeScript to show what this looks like:\n\n```ts\ntype PageParameters = {\n  postSlug: string;\n};\n\ntype ParametersForEachPage = Array<{\n  params: PageParameters;\n}>;\n\n// A function that takes no inputs, and returns ParametersForEachPage.\ntype getStaticPaths = () => ParametersForEachPage;\n```\n\nOr, for a concrete example:\n\n```ts\n// Since getStaticPaths often uses data that is loaded via network\n// or filesystem request, the function will be async and the return\n// value wrapped in a promise. If you don't know what that means,\n// just ignore it: the broad concept remains the same.\nexport async function getStaticPaths(): Promise<ParametersForEachPage> {\n  return [\n    { params: { postSlug: \"my-shipping-manifesto\" } },\n    { params: { postSlug: \"typescript-is-your-friend-i-swear\" } },\n    { params: { postSlug: \"thirstposting-as-bonding-activity\" } },\n  ];\n}\n```\n\nThis will generate 3 pages:\n\n1. `/posts/my-shipping-manifesto`\n2. `/posts/typescript-is-your-friend-i-swear`\n3. `/posts/thirstposting-as-bonding-activity`\n\nIf you want, you can stop here: **this is all your SSG needs to start using `getStaticPaths`.**\n\n## `getStaticPaths` and props\n\nIf you want to go deeper, however, there is yet another thing that\n`getStaticPaths` can do for you: given that it already has to work to produce\nthe value of the URL parameters for every page (a task that might require\npotentially-expensive data loading), wouldn't it be neat if it could use that\nchance to **also tell the SSG about the dynamic properties (\"`props`\") that\nchange page by page**?\n\nContinuing our blog example, our dynamic properties could be `tags`, `title`,\n`created_at`, and mostly anything that depends on the specific post and that we\nwant to avoid having to recalculate later. **The SSG doesn't really care what\n`props` you give it (and if you give any)**: it will simply pass them as-is to\neach page as it goes generate it, similarly to how we manually pass props to\ncomponents.\n\nOur TypeScript signatures will then become:\n\n```ts\ntype PageParameters = {\n  postSlug: string;\n};\n\ntype PageProperties = {\n  tags: string[];\n  title: string;\n  created_at: Date;\n};\n\ntype DataForEachPage = Array<{\n  params: PageParameters;\n  props: PageProperties;\n}>;\n\n// A function that takes no inputs, and returns DataForEachPage.\ntype getStaticPaths = () => DataForEachPage;\n```\n\nIn practice, our function will now look like this:\n\n```ts\nexport async function getStaticPaths(): Promise<GetStaticPathReturnValue> {\n    return [\n        // Our shipping post\n        {\n            params: { postSlug: \"my-shipping-manifesto\" },\n            props: {\n                tags: [\"fandom\", \"shipping\"],\n                title: \"Why I am Right and You are All Wrong\",\n                created_at: new Date('December 31, 2023 23:59:00')\n            }\n        },\n        // Our typescript-defense-squad post\n        {\n            params: { postSlug: \"typescript-is-your-friend-i-swear\" } },\n            props: {\n                tags: [\"coding\", \"typescript\", \"beginners\"],\n                title: \"Be kind to him, he's just trying to help\",\n                created_at: new Date('January 5, 2024 16:20:00')\n            }\n        },\n        // And so on so on...\n    ];\n}\n```\n\nNote that **unlike params (that the SSG must have to know what to generate), props\nare completely optional**: if we preferred, we could simply load the post data\nagain in the page itself by using the value in the `postSlug` URL parameter.\n\"Props\" is simply a \"since we're here, we might as well\" convenience.\n\n## `getStaticPaths` and content collections\n\nIn Astro, `getStaticPaths` is often used in tandem with content collections. There's\nnothing particularly special about using `getStaticPaths` this way, but let's go through\nhow such code typically looks bit by bit, and make sure that what's happening is clear.\n\nOnce again, our goal is to let the SSG know about:\n\n1. The value of `postSlug` for each one of our posts\n2. The properties that change page by page (we'll assume this is\n   every property of `entry.data` for our collection, plus the function to render\n   the content)\n\n```ts\nexport async function getStaticPaths() {\n  // If you're already loading this in the page itself, you cannot reuse it here:\n  // assume that getStaticPaths exists on its own and has no access to anything else\n  // on the file you're writing: it can only see what's written within it.\n  const blogEntries = await getCollection(\"posts\");\n  // Given an array, map will run the function for each entry, and put the returned\n  // value in a new array (at the same position). This tells the SSG to generate a\n  // page for each entry in our collection.\n  return blogEntries.map((blogPost) => {\n    return {\n      // Content collections give us a nice slug for each entry, kindly\n      // precalculated for us. This is the mandatory part.\n      params: { postSlug: blogPost.slug },\n      // The properties that change for every rendered page. This is a simple\n      // convenience since we have all the data available here.\n      props: {\n        // Our \"renderContent\" prop will contain the function that renders the blog\n        // post content. Rather than calling the function, we assign its value\n        // to the renderContent property, like we'd do for any other variable.\n        // In practice, calling renderContent() will be the same as calling render().\n        renderContent: blogPost.render,\n        // We spread the content of blogPost.data in the returned object, so that\n        // we have a prop for each value in the data, rather than the whole data\n        // object as a single prop.\n        ...blogPost.data,\n      },\n    };\n  });\n}\n```\n\nCalling this `getStaticPaths` yields a similar result to the above version: an array with\none entry for each entry in your collection, with the value of the `postSlug` URL\nparameter, and `props` that contain the dynamic data for each page.\n\n```ts\nexport async function getStaticPaths(): Promise<DataForEachPage> {\n    return [\n        // Our shipping post\n        {\n            params: { postSlug: \"my-shipping-manifesto\" },\n            props: {\n                renderContent: /*a function to render the blogpost content*/,\n                tags: [\"fandom\", \"shipping\"],\n                title: \"Why I am Right and You are All Wrong\",\n                created_at: new Date('December 31, 2023 23:59:00')\n            }\n        },\n        // Our typescript-defense-squad post\n        {\n            params: { postSlug: \"typescript-is-your-friend-i-swear\" } },\n            props: {\n                renderContent: /*a function to render the blogpost content*/,\n                tags: [\"coding\", \"typescript\", \"beginners\"],\n                title: \"Be kind to him, he's just trying to help\",\n                created_at: new Date('January 5, 2024 16:20:00')\n            }\n        },\n        // And so on so on...\n    ];\n}\n```\n\nOr in TypeScript terms:\n\n```ts\ntype PageParameters = {\n  postSlug: string;\n};\n\ntype PageProperties = {\n  // Warning: AstroComponent is not the real type, but don't worry about that.\n  renderContent: () => Promise<AstroComponent>;\n  tags: string[];\n  title: string;\n  created_at: Date;\n};\n\ntype DataForEachPage = Array<{\n  params: PageParameters;\n  props: PageProperties;\n}>;\n\n// A function that takes no inputs, and returns DataForEachPage. Since\n// content collections have an asynchronous loader, this function will return a\n// promise. Luckily, Astro is chill with that.\ntype getStaticPaths = () => Promise<DataForEachPage>;\n```\n\n### Optional Trick (Advanced): pre-render components within `getStaticPaths`\n\n<details>\n  <summary>Show me the trick!</summary>\n  <div>\n    If you want to *directly return the rendered component* (rather than the\n    function to render it), you will run into a problem: the `render` function is\n    an `async` function (that is returns a `Promise`), which means the function you\n    call to `map` every element of the array will also need to be `async` (and thus\n    return a `Promise`).\n\n    In TypeScript terms:\n\n```ts\n// Same as before\ntype PageParameters = {\n  postSlug: string;\n};\n\n// Now our properties include Content (the actual component) instead of renderContent (a reference\n// to the function to render the content)\ntype PageProperties = {\n  // Instead of being a reference to the function `render`, this is now the result of calling\n  // `await render()`\n  Content: AstroComponent;\n  tags: string[];\n  title: string;\n  created_at: Date;\n};\n\n// OOOPS, now this is an array of promises! This makes Astro very confused.\ntype DataForEachPage = Array<\n  Promise<{\n    params: PageParameters;\n    props: PageProperties;\n  }>\n>;\n```\n\n    If we want to pre-render the content, we can fix this in a somewhat-simple way: by waiting for\n    all the promises in the array to be resolved, and thus turning `DataForEachPage` back\n    to a simple array of objects. This is done using `Promise.all(array)`, which takes an\n    array of `Promise` and waits for them all to be resolved.\n\n```ts\nexport async function getStaticPaths() {\n    const blogEntries = await getCollection(\"posts\");\n    // We tell astro to wait for all promises in the array to be resolved before\n    // reading the value.\n    return Promise.all(\n        // Since we added async to the function passed to map, we're now returning\n        // an array of Promises (which will be waited on by Promise.all)\n        blogEntries.map(async (blogPost) => {\n        return {\n            params: { postSlug: blogPost.slug },\n            props: {\n                // We now return the content component directly (note the first-letter-uppercase\n                // convention, typical of components). Since `post.render` is an async function\n                // it will need to be awaited, which is what forced us to add async\n                // to the function passed to `map` and to have to use Promise.all.\n                Content: await post.render(),\n                ...blogPost.data,\n            },\n        };\n    });\n}\n```\n\n    Now we're back to the previous type signature, and all's right with ~~the world~~\n    Astro.\n\n    We can then use the rendered component in our `.astro` files by doing:\n\n```astro\n---\nconst { Content, tags, title, created_at } = Astro.props;\n---\n\n{title}\nPublished on: {created_at}\n\n<Content />\n\n```\n\n    </div>\n\n</details>\n\n## How do I use these values in my pages?\n\nAstro has its own way to get these values in your page, using the special `Astro` object\nthat is available in every `.astro` file. Simply access the `params` and `props` elements\nin this object to get your values.\n\n### Params\n\n```ts\n// Remember: this destructuring is equivalent to\n// const postSlug = Astro.params.postSlug;\nconst { postSlug } = Astro.params;\n```\n\n### Props\n\nProps work exactly as it would be in any component that accepts props:\n\n```astro\n---\nconst { renderContent, tags, title, created_at } = Astro.props;\n\n// If you want to use the rendered content you can render it and\n// then use it as any other tag. Note we capitalize the first letter\n// of content to remind ourself that's a component.\nconst Content = await renderContent();\n---\n\n{title}\nPublished on: {created_at}\n\n<Content />\n```\n\n## Final TypeScript typing\n\nHere's the final typescript types of the whole thing, which (if you've surrendered\nto the power of our Lord TypeScript) will help you remember how the concepts are related:\n\n```ts\ntype PageParameters = {\n  postSlug: string;\n};\n\ntype PageProperties = {\n  renderContent: () => Promise<AstroComponent>;\n  tags: string[];\n  title: string;\n  created_at: Date;\n};\n\ntype DataForEachPage = Array<{\n  params: PageParameters;\n  props: PageProperties;\n}>;\n\n// Astro will resolve that Promise for us, so we don't need to do anything\n// special with it. If Promises confuse you, you can pretend they're not here\n// in this case.\ntype getStaticPaths = () => Promise<DataForEachPage>;\n\n// The type of Astro.params will then be the same as PageParameters\ntype AstroParams = {\n  postSlug: string;\n};\n\n// And the type of Astro.props will then be the same as PageProperties\ntype AstroProps = {\n  renderContent: () => Promise<AstroComponent>;\n  tags: string[];\n  title: string;\n  created_at: Date;\n};\n```\n\n...and that is all! Go forth and use the power of `getStaticPaths` and let me know\nif anything is unclear.\n\n<details open>\n  <summary>Liked this? Help me change the face of web development!</summary>\n  <div>\n    Changing the web means changing who builds it! To this end, I create\n    accessible education targeted at growing hobbyists webdevs from isolated\n    beginners to open-source collaborators and maintainers. Learn how to{\" \"}\n    <a href=\"/support-me\">support this and more work on my Support Me page!</a>\n  </div>\n</details>\n\n<style>{`\n    details {\n        background-color: lightgray;\n        padding: 10px 20px;\n        margin: 20px 10px;\n        border-radius: 16px;\n    }\n    summary {\n        font-weight: bold;\n    }\n`}</style>\n";
						const data = {title:"A quick guide to \u003Ccode>getStaticPaths\u003C/code>",tagline:"A beginner-friendly explanation of why and how SSGs use this function.",created_at:new Date(1704020993000),unlisted:false,tags:["astro","typescript"],status:"pre-beta"};
						const _internal = {
							type: 'content',
							filePath: "/Users/essentialrandomness/projects/programming/essential-random/src/content/posts/get-static-paths/index.mdx",
							rawData: "\ntitle: A quick guide to `getStaticPaths`\ntagline: A beginner-friendly explanation of why and how SSGs use this function.\ntags:\n  - +astro\n  - +typescript\ncreated_at: 2023-12-31 11:09:53\nstatus: pre-beta",
						};

export { _internal, body, collection, data, id, slug };
